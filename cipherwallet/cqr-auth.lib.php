<?php

// common authorization functions used by the cipherwallet SDK

function cqr_auth($customer_id, $secret_key, $http_method, $resource, $params=array(), $hash_method="sha1") {
// create and return a set of custom headers to go in a cqr-authenticated API request, 
// including the corresponding CQR 1.0 Authorization: header

	// initialize the custom authorization headers
	$auth_headers = array(
		'X-Client-Id' => $customer_id,
		'X-Timestamp' => time(),
		'X-Nonce' => md5(mt_rand()),
		'X-Hash-Method' => $hash_method,
	);

	// prepare signature - headers and sorted parameters
	$signature = strtoupper($http_method) . " " . strtolower($resource) . "\n";
	$signature .= implode("\n", array_map(
		function($k, $v) { return $k . ":" . $v; },  
		array_keys($auth_headers), array_values($auth_headers)
	)) . "\n";
	if (is_array($params) && (count($params) > 0)) {
    	ksort($params);
		$signature .= implode("\n", array_map(
			function($k, $v) { return $k . "=" . $v; },  
			array_keys($params), array_values($params)
		));
	} else
	    $signature .= $params;
	    
	// hash with client secret key and base64-encode
	$auth_headers['Authorization'] = "CQR 1.0 " . base64_encode(hash_hmac(
		$hash_method, $signature, $secret_key, TRUE
	));
	if (DEBUG) file_put_contents(DEBUG,
		"\nsignature (len=" . strlen($signature) . "):\n" . $signature .
		"\nAuthorization: " . $auth_headers['Authorization'] . "\n", 
	FILE_APPEND);

	// return the array of headers
	return $auth_headers;

}

function cqr_verify($http_method, $uri, $headers, $params, $authorization) {
// verify an incoming, cqr-authenticated request

	$auth_parts = explode(" ", $authorization);
	if (
		(count($auth_parts) != 3) ||
		($auth_parts[0] != "CQR") ||
		($auth_parts[1] != "1.0")
	) 
		return FALSE;
	$received_crypto_sig = $auth_parts[2];

	// prepare signature with method, url...
	$signature = strtoupper($http_method) . " " . strtolower($uri) . "\n";
	// ... auth headers...
	$auth_headers = array('X-Client-Id', 'X-Timestamp', 'X-Nonce', 'X-Hash-Method');
	foreach ($auth_headers as $ah) {
		if (array_key_exists($ah, $headers) && (strlen($headers[$ah]) > 0))
			$signature .= $ah . ":" . $headers[$ah] . "\n";
		else
			return FALSE;
	}
	// ... and request params (if any)
	if (is_array($params) && (count($params) > 0)) {
		ksort($params);
		$signature .= implode("\n", array_map(
			function($k, $v) { return $k . "=" . $v; },  
			array_keys($params), array_values($params)
		));
	} else
	    $signature .= $params;
	if (DEBUG) file_put_contents(DEBUG,
		"expected signature (len=" . strlen($signature) . "):\n" . $signature . "\n", 
	FILE_APPEND);

	// verify timestamp drift
	if (!verify_timestamp((int)$headers['X-Timestamp']))
		return FALSE;
	// verify nonce uniqueness
	if (!verify_nonce($headers['X-Client-Id'], $headers['X-Nonce']))
		return FALSE;

	// build encrypted signature
	$crypto_sig = base64_encode(hash_hmac($headers['X-Hash-Method'], $signature, API_SECRET, TRUE));
	if (DEBUG) file_put_contents(DEBUG,
		"expected crypto sig: " . $crypto_sig . "\n", 
	FILE_APPEND);

	return $crypto_sig == $received_crypto_sig;

}

function cqr_authorize($auth_data) {
// A mobile user sent us, via the API server, an array of parameters:
//    user= their user id
//    timestamp= the request timestamp collected at source, in epoch format
//    nonce= a string randomly generated by the user, that should not repeat in a certain time interval
//    hash_method= the hash method used to generate the authorization string
//    authorization= the authorization string
// We reconstruct the signature based on this data, and check that we have the same signature hash 
//    for them in our database

	// user data validation
	if (
		!array_key_exists('cw_user', $auth_data) || (strlen($auth_data['cw_user']) == 0) || 
		!array_key_exists('authorization', $auth_data) || (strlen($auth_data['authorization']) == 0) || 
		!array_key_exists('timestamp', $auth_data) || !is_numeric($auth_data['timestamp'])  
	)
		return FALSE;
	if (!verify_timestamp($auth_data['timestamp']))
		return FALSE;
	if (array_key_exists('nonce', $auth_data) && !verify_nonce($auth_data['cw_user'], $auth_data['nonce']))
		return FALSE;
	$h_meth = accepted_hash_method(array_key_exists('hash_method', $auth_data) ? $auth_data['hash_method'] : "");
	if (strlen($h_meth) == 0)
		return FALSE;

	// lets go
	// pull signature from list of auth parameters - doesnt go into calculation
	$h_sig_received = str_replace(".", "+", $auth_data['authorization']);
	unset($auth_data['authorization']);
	// order the user's auth params list and build the signature string
	ksort($auth_data);
	$signature = implode("\n", array_map(
		function($k, $v) { return $k . "=" . $v; },  
		array_keys($auth_data), array_values($auth_data)
	));
	if (DEBUG) file_put_contents(DEBUG, 
		"calc signature (len=" . strlen($signature) . "):\n" . $signature . "\n", 
	FILE_APPEND);

	// get user's secret key and hash the signature with it
	list($uk, $user_id) = get_key_and_id_for_qr_login($auth_data['cw_user']);
	if (DEBUG) file_put_contents(DEBUG, 
		"key for user: '" . $uk . "' hashing " . $h_meth . "\n", 
	FILE_APPEND);
	if (strlen($uk) == 0)
		return FALSE;
	$h_sig_calculated = base64_encode(hash_hmac($h_meth, $signature, $uk, TRUE));

	if (DEBUG) file_put_contents(DEBUG,
		"hashed signatures: " . $h_sig_calculated . " " . $h_sig_received . "\n", 
	FILE_APPEND);
	return ($h_sig_calculated == $h_sig_received) ? $user_id : FALSE;

}

?>